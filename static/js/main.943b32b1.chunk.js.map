{"version":3,"sources":["double.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["DoubledCoord","x","y","this","row","col","a","b","k","createRows","order","rows","rowLength","i","j","deadCells","setInRows","coord","value","c","toRowAndColumn","addNewDot","console","log","newDot","FromRowAndColumn","forEach","arr","otherDot","diff","subtract","double1","add","double2","multiply","midDot","iterRowCol","func","countBlocked","count","clear","copy","newRows","result","map","indexes","push","join","randomOpenCell","selected","curMax","full","r","Math","random","fillOne","tries","lowestBlocked","lowestRows","randomCell","blocked","best","bestRows","App","React","useState","setTries","setOrder","useEffect","rerender","setNonce","useCallback","currentCount","countOnes","className","style","display","flexDirection","justifyContent","padding","onClick","type","onChange","e","Number","parseInt","target","maxWidth","str","splits","split","length","enteredRows","replace","cells","trim","filter","n","isNaN","deadcells","fromResult","width","fillerFunc","setTimeout","position","color","height","alignItems","textAlign","userSelect","backgroundColor","border","borderRadius","size","top","left","undefined","toString","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.943b32b1.chunk.js","sourcesContent":["export function CreateDoubledArray(order: number) {\r\n    let rows: number[][] = [];\r\n    // rows start at ORDER, and increase by 1 per row, reaching (2*ORDER) - 1 then decrease\r\n    let rowLength = order;\r\n    for (let i = 0; i < order; i++) {\r\n        rows[i] = [];\r\n        for (let j = 0; j < rowLength; j++) {\r\n            rows[i][j] = 0;\r\n        }\r\n        rowLength++;\r\n    }\r\n    rowLength--;\r\n    for (let i = order; i < order * 2 - 1; i++) {\r\n        rows[i] = [];\r\n        rowLength--;\r\n        for (let j = 0; j < rowLength; j++) {\r\n            rows[i][j] = 0;\r\n        }\r\n    }\r\n\r\n    return rows;\r\n}\r\n\r\nexport class DoubledCoord {\r\n    constructor(public x: number, public y: number) { }\r\n\r\n    static FromRowAndColumn(row: number, col: number) {\r\n        return new DoubledCoord(row, col * 2 - row);\r\n    }\r\n\r\n    toString() { return `${this.x}, ${this.y}` };\r\n\r\n    toRowAndColumn() {\r\n        let row = this.x;\r\n        let col = (this.y + this.x) / 2;\r\n        return { row, col };\r\n    }\r\n\r\n    static add(a: DoubledCoord, b: DoubledCoord) {\r\n        return new DoubledCoord(a.x + b.x, a.y + b.y);\r\n    }\r\n\r\n    static subtract(a: DoubledCoord, b: DoubledCoord) {\r\n        return new DoubledCoord(a.x - b.x, a.y - b.y);\r\n    }\r\n\r\n    static multiply(a: DoubledCoord, k: number) {\r\n        return new DoubledCoord(a.x * k, a.y * k);\r\n    }\r\n}","import { create } from 'domain';\nimport React from 'react';\nimport './App.css';\nimport { DoubledCoord } from './double';\n\ninterface Hex {\n  x: number;\n  y: number;\n}\n\nfunction distance(a: Hex, b: Hex): number {\n  return 0;\n}\n\nconst startOrder = 4;\n\nfunction createRows(order: number) {\n  let rows: number[][] = [];\n  // rows start at ORDER, and increase by 1 per row, reaching (2*ORDER) - 1 then decrease\n  let rowLength = order;\n  for (let i = 0; i < order; i++) {\n    rows[i] = [];\n    for (let j = 0; j < rowLength; j++) {\n      rows[i][j] = 0;\n    }\n    rowLength++;\n  }\n\n  // instead of shrinking OFFSET the new ones!\n  let deadCells = 0;\n  for (let i = order; i < order * 2 - 1; i++) {\n    rows[i] = [];\n    deadCells++;\n    rowLength--;\n    for (let j = 0; j < rowLength + deadCells - 1; j++) {\n      rows[i][j] = 0;\n      if (j < deadCells) {\n        rows[i][j] = -1;\n      }\n    }\n  }\n\n  return rows;\n}\n\nvar rows: number[][] = createRows(startOrder);\n\nfunction setInRows(rows: number[][], coord: DoubledCoord, value: number) {\n  const c = coord.toRowAndColumn();\n  if (rows[c.row] && rows[c.row][c.col] >= 0) {\n    rows[c.row][c.col] = value;\n  }\n}\n\n// -1 is empty cell, just for offset, always ignore these and never set a value there\n// 0 is empty\n// 1 is filled\n// 2 is blocked! (already a mid point!)\nfunction addNewDot(rows: number[][], i: number, j: number) {\n  if (rows[i][j] != 0) { return; }\n  console.log(\"Adding dot\", i,j);\n\n  const newDot = DoubledCoord.FromRowAndColumn(i, j);\n\n  // for EVERY non-0 spot we need to find a mid point. if INTEGER then we block them\n\n  rows.forEach((arr, row) => {\n    arr.forEach((x, col) => {\n      if (x === 1) {\n        const otherDot = DoubledCoord.FromRowAndColumn(row, col);\n\n        // TODO block double points\n        const diff = DoubledCoord.subtract(newDot, otherDot);\n        const double1 = DoubledCoord.add(newDot, diff);\n        const double2 = DoubledCoord.add(otherDot, DoubledCoord.multiply(diff, -1));\n        setInRows(rows, double1, 3);\n        setInRows(rows, double2, 3);\n\n        // TODO block mid point\n        // mid point should be AVERAGE og the 2 spots.\n        const midDot = DoubledCoord.multiply(DoubledCoord.add(otherDot, newDot), .5);\n        const mid = midDot.toRowAndColumn();\n        setInRows(rows, midDot, 2);\n      }\n    });\n  })\n\n  rows[i][j] = 1;\n}\n\nfunction iterRowCol(rows: number[][], func: (value: number, row: number, col: number, rows: number[][]) => void) {\n  rows.forEach((arr, row) => {\n    arr.forEach((value, col) => {\n      func(value, row, col, rows);\n    });\n  });\n}\n\nfunction countOnes(rows: number[][]) {\n  let count = 0;\n  iterRowCol(rows, (x) => {\n    if (x === 1) { count++; }\n  });\n  return count;\n}\n\nfunction countBlocked(rows: number[][]) {\n  let count = 0;\n  iterRowCol(rows, (x) => {\n    if (x > 1) { count++; }\n  });\n  return count;\n}\n\n\nfunction clear(rows: number[][]) {\n  iterRowCol(rows, (x, row, col) => {\n    if (x > 0) { rows[row][col] = 0; }\n  });\n}\n\nfunction copy(rows: number[][]) {\n  let newRows: number[][] = [];\n  iterRowCol(rows, (value, row, col) => {\n    newRows[row] = newRows[row] || [];\n    newRows[row][col] = value;\n  });\n  return newRows;\n}\n\nfunction result(rows: number[][]) {\n  return rows.map((row) => {\n    const indexes: number[] = [];\n    let deadCells = 0;\n    row.forEach((x, col) => {\n      if (x === -1) { deadCells++ }\n      // this doesn't handle DEAD CELLS!\n      if (x === 1) indexes.push(col - deadCells);\n    });\n    return `{${indexes.join(',')}}`;\n  }).join(', ');\n}\n\nfunction fromResult(str: string){\n  console.log(\"entered!\");\n\n  // parse the string and turn it into rows and set the rows...\n  const splits = str.split(\"},\");\n  const order = (rows.length + 1) / 2;\n  const enteredRows = createRows(order);\n\n  // this doesn't handle DEAD CELLS!\n  splits.forEach((row, i) => {\n    row = row.replace(\"{\", \"\");\n    row = row.replace(\"}\", \"\");\n    console.log(\"row\", row);\n    const cells = row.split(\",\").map(c => Number.parseInt(c.trim())).filter(n => !isNaN(n));\n    console.log(cells);\n    // j needs to be offset by number of deadcells in that row.\n    const deadcells = enteredRows[i].filter(x => x===-1).length;\n    cells.forEach(j => {\n      addNewDot(enteredRows, i, j + deadcells);\n    });\n  });\n\n  return {\n    order,\n    rows: enteredRows,\n  };\n}\n\nfunction randomOpenCell(rows: number[][]) {\n  let selected = { row: 0, col: 0 };\n  let curMax = -1;\n  let full = true;\n  iterRowCol(rows, (x, row, col) => {\n    if (x === 0) {\n      full = false;\n      const r = Math.random();\n      if (r > curMax) {\n        curMax = r;\n        selected = { row, col };\n      }\n    }\n  });\n  if (full) { throw \"FULL!\" }\n  return selected;\n}\n\nfunction fillOne(rows: number[][], tries = 10) {\n  // ideally search open cells for whatever adds the LEAST blocked tiles\n  // or just check a few \n  let lowestBlocked = 999999999999999;\n  let lowestRows = rows;\n  for (let i = 0; i < tries; i++) {\n    const randomCell = randomOpenCell(rows);\n    const newRows = copy(rows);\n    addNewDot(newRows, randomCell.row, randomCell.col);\n    const blocked = countBlocked(newRows);\n    if (blocked < lowestBlocked) {\n      lowestBlocked = blocked;\n      lowestRows = newRows;\n    }\n  }\n\n  return lowestRows;\n}\n\nlet best = 0;\nlet bestRows: number[][] = [];\n\nfunction App() {\n  const [tries, setTries] = React.useState(10);\n  const [order, setOrder] = React.useState(startOrder);\n  React.useEffect(() => {\n    rows = createRows(order);\n    best = 0;\n    rerender();\n  }, [order, setOrder]);\n\n  const [, setNonce] = React.useState(Math.random());\n  const rerender = React.useCallback(() => setNonce(Math.random()), [setNonce]);\n\n  const currentCount = countOnes(rows);\n  if (currentCount > best) {\n    best = currentCount;\n    bestRows = copy(rows);\n  }\n\n  return (\n    <div className=\"App\" >\n      <div style={{ display: \"flex\", flexDirection: \"row\", justifyContent: \"space-around\", padding: 10 }}>\n        <button onClick={() => { clear(rows); rerender(); }}>Clear</button>\n        <span>Order: <input type=\"number\" value={order} onChange={e => {\n          setOrder(Number.parseInt(e.target.value));\n          rerender();\n        }} /></span>\n        <span> Score: {currentCount}</span>\n        <span> Best: {best}</span>\n      </div>\n\n      <div>\n        Current: <input style={{ maxWidth: 2000 }} value={result(rows)} onChange={(e) => {\n          const str = e.target.value;\n          const result = fromResult(str);\n          rows = result.rows;\n          setOrder(result.order);\n          rerender();\n        }} />  Best<input style={{ maxWidth: 200 }} value={result(bestRows)} />\n\n      </div>\n      <div>\n        Tries: <input type=\"number\" value={tries} style={{width: 50}} onChange={(e)=>setTries(Number.parseInt(e.target.value))} />\n        <button onClick={() => {\n          try {\n            rows = fillOne(rows, tries);\n            rerender();\n          }\n          catch { }\n        }}>Fill NEXT</button>\n        <button onClick={() => {\n          const fillerFunc = () =>{\n            try{\n              rows = fillOne(rows, tries);\n              rerender();\n              setTimeout(fillerFunc, 0);\n            }\n            catch {};\n          }\n\n          fillerFunc();\n        }}>Fill All</button>\n        <button onClick={() => {\n          let count = 0;\n          let maxCount = 10;\n          const fillerFunc = () =>{\n            if(count > maxCount){ return;}\n            try{\n              rows = fillOne(rows, tries);\n              rerender();\n              setTimeout(fillerFunc, 0);\n            }\n            catch {\n              count++;\n              clear(rows);\n              setTimeout(fillerFunc, 0);\n            };\n          };\n          fillerFunc();\n        }}>Fill 10</button>\n      </div>\n\n      <div style={{ position: \"relative\" }}>\n        {order > 50 ? \"Sorry this is too big right now. Set order to 50 or less.\" : null}\n        {order <= 50 ? rows.map((r, i) => <div key={i} style={{ display: \"flex\", justifyContent: \"center\" }}>\n          {r.map((x, j) => {\n            let color = \"white\";\n            switch (x) {\n              case -1: color = \"lightgrey\"; break;\n              case 1: color = \"red\"; break;\n              case 2: case 3: color = \"grey\"; break;\n            }\n\n            const size = 50;\n\n            return <div key={j}\n              style={{\n                width: size,\n                height: size,\n                display: x === -1 ? \"none\" : \"flex\",\n                alignItems: \"center\",\n                textAlign: \"center\",\n                justifyContent: \"center\",\n                userSelect: \"none\",\n                backgroundColor: color,\n                border: \"1px solid black\",\n                borderRadius: size * 2,\n                position: \"absolute\",\n                top: (DoubledCoord.FromRowAndColumn(i, j).x) * size,\n                left: (DoubledCoord.FromRowAndColumn(i, j).y + order) * (size + 5) / 2,\n              }}\n              onClick={rows[i][j] <= 1 ? () => {\n                if (rows[i][j] === 1) {\n                  rows[i][j] = 0;\n                  // need to clear everything! yuck!\n                }\n                else if (rows[i][j] === 0) {\n                  addNewDot(rows, i, j);\n                }\n                rerender();\n              } : undefined}>{DoubledCoord.FromRowAndColumn(i, j).toString()}</div>;\n          })}\n        </div>) : null}\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}