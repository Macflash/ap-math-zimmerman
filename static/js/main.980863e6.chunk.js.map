{"version":3,"sources":["double.ts","hexgrid.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["DoubledCoord","x","y","this","row","col","a","b","k","createRows","order","rows","rowLength","i","j","deadCells","iterRowCol","func","forEach","arr","value","setInRows","coord","c","toRowAndColumn","getDoubleCoords","newDot","doublePts","otherDot","FromRowAndColumn","diff","subtract","double1","add","double2","multiply","push","getMiddleCoords","middlePts","midDot","addNewDot","pt","testAddNewDot","Number","MAX_SAFE_INTEGER","newPts","count","toString","clear","result","map","indexes","join","getRandom","max","Math","floor","random","time","start","performance","now","fast_randomOpenCell","length","old_randomOpenCell","selected","curMax","full","r","fillOne","tries","lowestBlocked","lowestCell","randomCell","blocked","console","log","newtime","rowOrder","num","index","rand","sort","randomOrder","row_arr","openIndexes","randomOpenCell","oldtime","best","bestRows","App","React","useState","scale","setScale","setTries","setOrder","setNonce","rerender","useCallback","currentCount","countOnes","newRows","copy","canvasRef","useRef","current","context","getContext","w","width","window","innerWidth","h","height","innerHeight","clearRect","fillStyle","fillRect","color","className","style","display","flexDirection","justifyContent","padding","onClick","type","min","onChange","e","newScale","parseFloat","target","newOrder","parseInt","maxWidth","str","splits","split","enteredRows","replace","cells","trim","filter","n","isNaN","deadcells","fromResult","readOnly","fillerFunc","setTimeout","newRow","ref","position","alignItems","textAlign","userSelect","backgroundColor","border","borderRadius","size","top","left","undefined","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.980863e6.chunk.js","sourcesContent":["export function CreateDoubledArray(order: number) {\r\n    let rows: number[][] = [];\r\n    // rows start at ORDER, and increase by 1 per row, reaching (2*ORDER) - 1 then decrease\r\n    let rowLength = order;\r\n    for (let i = 0; i < order; i++) {\r\n        rows[i] = [];\r\n        for (let j = 0; j < rowLength; j++) {\r\n            rows[i][j] = 0;\r\n        }\r\n        rowLength++;\r\n    }\r\n    rowLength--;\r\n    for (let i = order; i < order * 2 - 1; i++) {\r\n        rows[i] = [];\r\n        rowLength--;\r\n        for (let j = 0; j < rowLength; j++) {\r\n            rows[i][j] = 0;\r\n        }\r\n    }\r\n\r\n    return rows;\r\n}\r\n\r\nexport interface Cell { row: number, col: number};\r\n\r\nexport class DoubledCoord {\r\n    constructor(public x: number, public y: number) { }\r\n\r\n    static FromRowAndColumn(row: number, col: number) {\r\n        return new DoubledCoord(row, col * 2 - row);\r\n    }\r\n\r\n    toString() { return `${this.x}, ${this.y}` };\r\n\r\n    toRowAndColumn(): Cell {\r\n        let row = this.x;\r\n        let col = (this.y + this.x) / 2;\r\n        return { row, col };\r\n    }\r\n\r\n    static add(a: DoubledCoord, b: DoubledCoord) {\r\n        return new DoubledCoord(a.x + b.x, a.y + b.y);\r\n    }\r\n\r\n    static subtract(a: DoubledCoord, b: DoubledCoord) {\r\n        return new DoubledCoord(a.x - b.x, a.y - b.y);\r\n    }\r\n\r\n    static multiply(a: DoubledCoord, k: number) {\r\n        return new DoubledCoord(a.x * k, a.y * k);\r\n    }\r\n}","import { Cell, DoubledCoord } from \"./double\";\r\n\r\nexport class Grid {\r\n    // Store all cells in an offset hex grid\r\n    private rows: number[][];\r\n\r\n    // We will want to update this whenever we change the grid\r\n    private counts: CellCount;\r\n\r\n    constructor(public readonly order: number) {\r\n        this.rows = createRows(order);\r\n        this.counts = countRows(this.rows);\r\n    }\r\n\r\n    ToResult() {\r\n        return this.rows.map((row) => {\r\n            const indexes: number[] = [];\r\n            let deadCells = 0;\r\n            row.forEach((x, col) => {\r\n                if (x === -1) { deadCells++ }\r\n                // this doesn't handle DEAD CELLS!\r\n                if (x === 1) indexes.push(col - deadCells);\r\n            });\r\n            return `{${indexes.join(',')}}`;\r\n        }).join(', ');\r\n    }\r\n\r\n    static FromResult(str: string) {\r\n        // TODO\r\n        //     // parse the string and turn it into rows and set the rows...\r\n        //    const splits = str.split(\"},\");\r\n        //    const order = (splits.length + 1) / 2;\r\n        //    const grid = new HexGrid(order);\r\n\r\n        //    // this doesn't handle DEAD CELLS!\r\n        //    splits.forEach((row, i) => {\r\n        //        row = row.replace(\"{\", \"\");\r\n        //        row = row.replace(\"}\", \"\");\r\n        //        console.log(\"row\", row);\r\n        //        const cells = row.split(\",\").map(c => Number.parseInt(c.trim())).filter(n => !isNaN(n));\r\n        //        console.log(cells);\r\n        //        // j needs to be offset by number of deadcells in that row.\r\n        //        const deadcells = grid.rows[i].filter(x => x === -1).length;\r\n        //        cells.forEach(j => {\r\n        //        addNewDot(enteredRows, i, j + deadcells);\r\n        //        });});\r\n\r\n        //        return {\r\n        //          order,\r\n        //          rows: enteredRows,\r\n        //        };\r\n    }\r\n}\r\n\r\nexport function createRows(order: number) {\r\n    let rows: number[][] = [];\r\n    // rows start at ORDER, and increase by 1 per row, reaching (2*ORDER) - 1 then decrease\r\n    let rowLength = order;\r\n    for (let i = 0; i < order; i++) {\r\n        rows[i] = [];\r\n        for (let j = 0; j < rowLength; j++) {\r\n            rows[i][j] = 0;\r\n        }\r\n        rowLength++;\r\n    }\r\n\r\n    // instead of shrinking OFFSET the new ones!\r\n    let deadCells = 0;\r\n    for (let i = order; i < order * 2 - 1; i++) {\r\n        rows[i] = [];\r\n        deadCells++;\r\n        rowLength--;\r\n        for (let j = 0; j < rowLength + deadCells - 1; j++) {\r\n            rows[i][j] = 0;\r\n            if (j < deadCells) {\r\n                rows[i][j] = -1;\r\n            }\r\n        }\r\n    }\r\n\r\n    return rows;\r\n}\r\n\r\nexport function iterRowCol(rows: number[][], func: (value: number, row: number, col: number, rows: number[][]) => void) {\r\n    rows.forEach((arr, row) => {\r\n        arr.forEach((value, col) => {\r\n            func(value, row, col, rows);\r\n        });\r\n    });\r\n}\r\n\r\n\r\ntype CellCount = { [value: number]: number };\r\nexport function countRows(rows: number[][]) {\r\n    const counts: CellCount = {};\r\n    iterRowCol(rows, (x) => {\r\n        counts[x] = counts[x] || 0;\r\n        counts[x]++;\r\n    });\r\n    return counts;\r\n}\r\n","import { create } from 'domain';\nimport React from 'react';\nimport './App.css';\nimport { Cell, DoubledCoord } from './double';\nimport { createRows, iterRowCol } from './hexgrid';\n\ninterface Hex {\n  x: number;\n  y: number;\n}\n\nfunction distance(a: Hex, b: Hex): number {\n  return 0;\n}\n\nconst startOrder = 4;\n\nvar rows: number[][] = createRows(startOrder);\n\nfunction setInRows(rows: number[][], coord: DoubledCoord, value: number) {\n  const c = coord.toRowAndColumn();\n  if (rows[c.row] && rows[c.row][c.col] >= 0) {\n    rows[c.row][c.col] = value;\n  }\n}\n\nfunction getDoubleCoords(rows: number[][], newDot: DoubledCoord) {\n  const doublePts: DoubledCoord[] = [];\n  rows.forEach((arr, row) => {\n    arr.forEach((x, col) => {\n      if (x === 1) {\n        const otherDot = DoubledCoord.FromRowAndColumn(row, col);\n\n        // TODO block double points\n        const diff = DoubledCoord.subtract(newDot, otherDot);\n        const double1 = DoubledCoord.add(newDot, diff);\n        const double2 = DoubledCoord.add(otherDot, DoubledCoord.multiply(diff, -1));\n        doublePts.push(double1);\n        doublePts.push(double2);\n      }\n    });\n  });\n\n  return doublePts;\n}\n\nfunction getMiddleCoords(rows: number[][], newDot: DoubledCoord) {\n  const middlePts: DoubledCoord[] = [];\n  rows.forEach((arr, row) => {\n    arr.forEach((x, col) => {\n      if (x === 1) {\n        const otherDot = DoubledCoord.FromRowAndColumn(row, col);\n        const midDot = DoubledCoord.multiply(DoubledCoord.add(otherDot, newDot), .5);\n        middlePts.push(midDot);\n      }\n    });\n  });\n\n  return middlePts;\n}\n\n// -1 is empty cell, just for offset, always ignore these and never set a value there\n// 0 is empty\n// 1 is filled\n// 2 is blocked! (already a mid point!)\nfunction addNewDot(rows: number[][], i: number, j: number) {\n  if (rows[i][j] != 0) { return; }\n\n  const newDot = DoubledCoord.FromRowAndColumn(i, j);\n\n  const doublePts = getDoubleCoords(rows, newDot);\n  doublePts.forEach(pt => {\n    setInRows(rows, pt, 3);\n  });\n\n  const middlePts = getMiddleCoords(rows, newDot);\n  middlePts.forEach(pt => {\n    setInRows(rows, pt, 2);\n  })\n\n  rows[i][j] = 1;\n}\n\nfunction testAddNewDot(rows: number[][], i: number, j: number) {\n  if (rows[i][j] != 0) { return Number.MAX_SAFE_INTEGER; }\n\n  const newDot = DoubledCoord.FromRowAndColumn(i, j);\n  const doublePts = getDoubleCoords(rows, newDot);\n  const middlePts = getMiddleCoords(rows, newDot);\n\n  const newPts: { [key: string]: boolean } = {};\n\n  let count = 0;\n  doublePts.forEach(pt => {\n    if (!newPts[pt.toString()]) count++;\n    newPts[pt.toString()] = true;\n  });\n\n  middlePts.forEach(pt => {\n    if (!newPts[pt.toString()]) count++;\n    newPts[pt.toString()] = true;\n  });\n\n  return count;\n}\n\nfunction countOnes(rows: number[][]) {\n  let count = 0;\n  iterRowCol(rows, (x) => {\n    if (x === 1) { count++; }\n  });\n  return count;\n}\n\nfunction clear(rows: number[][]) {\n  iterRowCol(rows, (x, row, col) => {\n    if (x > 0) { rows[row][col] = 0; }\n  });\n}\n\nfunction copy(rows: number[][]) {\n  let newRows: number[][] = [];\n  iterRowCol(rows, (value, row, col) => {\n    newRows[row] = newRows[row] || [];\n    newRows[row][col] = value;\n  });\n  return newRows;\n}\n\nfunction result(rows: number[][]) {\n  return rows.map((row) => {\n    const indexes: number[] = [];\n    let deadCells = 0;\n    row.forEach((x, col) => {\n      if (x === -1) { deadCells++ }\n      // this doesn't handle DEAD CELLS!\n      if (x === 1) indexes.push(col - deadCells);\n    });\n    return `{${indexes.join(',')}}`;\n  }).join(', ');\n}\n\nfunction fromResult(str: string) {\n  console.log(\"entered!\");\n\n  // parse the string and turn it into rows and set the rows...\n  const splits = str.split(\"},\");\n  const order = (splits.length + 1) / 2;\n  console.log(\"I think it is order\", order);\n  const enteredRows = createRows(order);\n\n  // this doesn't handle DEAD CELLS!\n  splits.forEach((row, i) => {\n    row = row.replace(\"{\", \"\");\n    row = row.replace(\"}\", \"\");\n    console.log(\"row\", row);\n    const cells = row.split(\",\").map(c => Number.parseInt(c.trim())).filter(n => !isNaN(n));\n    console.log(cells);\n    // j needs to be offset by number of deadcells in that row.\n    const deadcells = enteredRows[i].filter(x => x === -1).length;\n    cells.forEach(j => {\n      addNewDot(enteredRows, i, j + deadcells);\n    });\n  });\n\n  return {\n    order,\n    rows: enteredRows,\n  };\n}\n\nfunction getRandom(max: number) {\n  return Math.floor(Math.random() * max);\n}\n\nfunction randomOrder(num: number) {\n  // place a random order or 1-num in an array.\n  var arr = [];\n  for (let i = 0; i < num; i++) {\n    arr.push({\n      index: i,\n      rand: Math.random()\n    });\n  }\n  arr.sort((a, b) => a.rand - b.rand);\n  return arr.map(x => x.index);\n}\n\nfunction time(count: number, func: () => void) {\n  const start = performance.now();\n\n  for (let i = 0; i < count; i++) {\n    func();\n  }\n\n  return performance.now() - start;\n}\n\nconsole.log(() => {\n  console.log(\"testing!\");\n\n  const newtime = time(1000, () => randomOpenCell(rows));\n  console.log(\"new time!\", newtime);\n\n  const oldtime = time(1000, () => old_randomOpenCell(rows));\n\n  console.log(\"old time!\", oldtime);\n\n});\n\nfunction randomOpenCell(rows: number[][]) {\n  const rowOrder = randomOrder(rows.length);\n  for (let i = 0; i < rows.length; i++) {\n    const row = rowOrder[i];\n    const row_arr = rows[row];\n\n    const openIndexes: number[] = [];\n    row_arr.forEach((x, col) => {\n      if (x === 0) {\n        openIndexes.push(col);\n      }\n    });\n\n    if (openIndexes.length) {\n      const col = getRandom(openIndexes.length);\n      return { row, col };\n    }\n  }\n\n  throw \"FULL!\";\n}\n\n// This checks every cell currently, which is quite impractical at larger sizes\nfunction fast_randomOpenCell(rows: number[][]) {\n  // this like.. DIES at the end....\n  for (let i = 0; i < 10000; i++) {\n    const row = getRandom(rows.length);\n    const col = getRandom(rows[row].length);\n    if (rows[row][col] === 0) {\n      return { row, col };\n    }\n  }\n  return old_randomOpenCell(rows);\n}\n\n// This checks every cell currently, which is quite impractical at larger sizes\nfunction old_randomOpenCell(rows: number[][]) {\n  let selected = { row: 0, col: 0 };\n  let curMax = -1;\n  let full = true;\n\n  // pick a random open cell \n  iterRowCol(rows, (x, row, col) => {\n    if (x === 0) {\n      full = false;\n      const r = Math.random();\n      if (r > curMax) {\n        curMax = r;\n        selected = { row, col };\n      }\n    }\n  });\n  if (full) { throw \"FULL!\" }\n  return selected;\n}\n\nfunction fillOne(rows: number[][], tries = 10) {\n  // ideally search open cells for whatever adds the LEAST blocked tiles\n  // or just check a few \n  let lowestBlocked = Number.MAX_SAFE_INTEGER;\n  let lowestCell: Cell | null = null;\n  for (let i = 0; i < tries; i++) {\n    // This is a lot of overhead. really we just want to check what NEW ones would be added.\n    const randomCell = fast_randomOpenCell(rows);\n    const blocked = testAddNewDot(rows, randomCell.row, randomCell.col);\n    // this should be outdated now and is way slower (i hope)\n    // const newRows = copy(rows);\n    // addNewDot(newRows, randomCell.row, randomCell.col);\n    // const blocked = countBlocked(newRows);\n    if (blocked < lowestBlocked) {\n      lowestBlocked = blocked;\n      lowestCell = randomCell;\n    }\n  }\n\n  addNewDot(rows, lowestCell!.row, lowestCell!.col);\n  return rows;\n}\n\nlet best = 0;\nlet bestRows: number[][] = [];\n\nfunction App() {\n  const [scale, setScale] = React.useState(100);\n  const [tries, setTries] = React.useState(10);\n  const [order, setOrder] = React.useState(startOrder);\n\n  const [, setNonce] = React.useState(Math.random());\n  const rerender = React.useCallback(() => setNonce(Math.random()), [setNonce]);\n\n  const currentCount = countOnes(rows);\n  if (currentCount > best) {\n    best = currentCount;\n    bestRows = copy(rows);\n  }\n\n  const canvasRef = React.useRef<HTMLCanvasElement>(null);\n  if (canvasRef.current) {\n    const context = canvasRef.current.getContext(\"2d\")!;\n    const w = canvasRef.current.width = window.innerWidth;\n    const h = canvasRef.current.height = window.innerHeight - 120;\n    context.clearRect(0, 0, w, h);\n    context.fillStyle = \"black\";\n    context.fillRect(0, 0, w, h);\n\n    const scale = h / rows.length;\n\n    iterRowCol(rows, (value, row, col) => {\n      let color = \"white\";\n      switch (value) {\n        case -1: color = \"lightgrey\"; return;\n        case 1: color = \"red\"; break;\n        case 2: case 3: color = \"grey\"; break;\n      }\n\n      context.fillStyle = color;\n      const y = (DoubledCoord.FromRowAndColumn(row, col).x) * scale;\n      const x = (DoubledCoord.FromRowAndColumn(row, col).y + order) * (scale) / 2;\n      context.fillRect(x, y, scale, scale);\n    });\n  }\n\n  return (\n    <div className=\"App\" >\n      <div style={{ display: \"flex\", flexDirection: \"row\", justifyContent: \"space-around\", padding: 10 }}>\n        <button onClick={() => { clear(rows); rerender(); }}>Clear</button>\n        <span>Scale: <input type=\"range\" min=\"1\" max=\"100\" value={scale} onChange={e => {\n          const newScale = Number.parseFloat(e.target.value);\n          setScale(newScale);\n          rerender();\n        }} /></span>\n        <span>Order: <input type=\"number\" value={order} onChange={e => {\n          const newOrder = Number.parseInt(e.target.value)\n          setOrder(newOrder);\n          rows = createRows(newOrder);\n          best = 0;\n          rerender();\n        }} /></span>\n        <span> Score: {currentCount}</span>\n        <span> Best: {best}</span>\n      </div>\n\n      <div>\n        Current: <input style={{ maxWidth: 2000 }} value={result(rows)} onChange={(e) => {\n          const str = e.target.value;\n          const result = fromResult(str);\n          rows = result.rows;\n          setOrder(result.order);\n          rerender();\n        }} />  Best: <input readOnly style={{ maxWidth: 200 }} value={result(bestRows)} />\n\n      </div>\n      <div>\n        Tries: <input type=\"number\" value={tries} style={{ width: 50 }} onChange={(e) => setTries(Number.parseInt(e.target.value))} />\n        <button onClick={() => {\n          try {\n            rows = fillOne(rows, tries);\n            rerender();\n          }\n          catch { }\n        }}>Fill NEXT</button>\n        <button onClick={() => {\n          const fillerFunc = () => {\n            try {\n              rows = fillOne(rows, tries);\n              rerender();\n              setTimeout(fillerFunc, 0);\n            }\n            catch { };\n          }\n\n          fillerFunc();\n        }}>Fill All</button>\n        <button onClick={() => {\n          let count = 0;\n          let maxCount = 10;\n          const fillerFunc = () => {\n            if (count > maxCount) { return; }\n            try {\n              rows = fillOne(rows, tries);\n              rerender();\n              setTimeout(fillerFunc, 0);\n            }\n            catch {\n              count++;\n              clear(rows);\n              setTimeout(fillerFunc, 0);\n            };\n          };\n          fillerFunc();\n        }}>Fill 10</button>\n\n        <button onClick={() => {\n          // if FULL clear(rows);\n          const fillerFunc = () => {\n            try {\n              const row = rows[order - 1];\n              const newRow = fillOne([row], tries);\n              rows[order - 1] = newRow[0];\n              rerender();\n              setTimeout(fillerFunc, 0);\n            }\n            catch { };\n          }\n\n          fillerFunc();\n        }}>Fill middle row</button>\n        \n        {/* <button onClick={() => {\n          // where are the corners?\n          // 2 in first row.\n          // 2 in middle row\n          // 2 in last row (after dead cells)\n          const fillerFunc = () => {\n            try {\n              const row = rows[order - 1];\n              const newRow = fillOne([row], tries);\n              rows[order - 1] = newRow[0];\n              rerender();\n              setTimeout(fillerFunc, 0);\n            }\n            catch { };\n          }\n\n          fillerFunc();\n        }}>Fill near corners</button> */}\n\n      </div>\n\n      {order > 50 ? <canvas style={{ display: \"block\", width: \"100%\", height: \"100%\" }} ref={canvasRef}></canvas> : null}\n\n      <div style={{ position: \"relative\", scale: `${scale / 100}` }}>\n        {order <= 50 ? rows.map((r, i) => <div key={i} style={{ display: \"flex\", justifyContent: \"center\" }}>\n          {r.map((x, j) => {\n            let color = \"white\";\n            switch (x) {\n              case -1: color = \"lightgrey\"; break;\n              case 1: color = \"red\"; break;\n              case 2: case 3: color = \"grey\"; break;\n            }\n\n            const size = 50;\n\n            return <div key={j}\n              style={{\n                width: size,\n                height: size,\n                display: x === -1 ? \"none\" : \"flex\",\n                alignItems: \"center\",\n                textAlign: \"center\",\n                justifyContent: \"center\",\n                userSelect: \"none\",\n                backgroundColor: color,\n                border: \"1px solid black\",\n                borderRadius: size * 2,\n                position: \"absolute\",\n                top: (DoubledCoord.FromRowAndColumn(i, j).x) * size,\n                left: (DoubledCoord.FromRowAndColumn(i, j).y + order) * (size + 5) / 2,\n              }}\n              onClick={rows[i][j] <= 1 ? () => {\n                if (rows[i][j] === 1) {\n                  rows[i][j] = 0;\n                  // need to clear everything! yuck!\n                }\n                else if (rows[i][j] === 0) {\n                  addNewDot(rows, i, j);\n                }\n                rerender();\n              } : undefined}>{DoubledCoord.FromRowAndColumn(i, j).toString()}</div>;\n          })}\n        </div>) : null}\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}