{"version":3,"sources":["double.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["DoubledCoord","x","y","this","row","col","a","b","k","createRows","order","rows","rowLength","i","j","deadCells","setInRows","coord","value","c","toRowAndColumn","addNewDot","newDot","FromRowAndColumn","forEach","arr","otherDot","diff","subtract","double1","add","double2","multiply","midDot","iterRowCol","func","countBlocked","count","clear","copy","newRows","result","map","indexes","push","join","getRandom","max","Math","floor","random","time","start","performance","now","fast_randomOpenCell","length","old_randomOpenCell","selected","curMax","full","r","fillOne","tries","lowestBlocked","lowestRows","randomCell","blocked","console","log","newtime","rowOrder","num","index","rand","sort","randomOrder","row_arr","openIndexes","randomOpenCell","oldtime","best","bestRows","App","React","useState","scale","setScale","setTries","setOrder","setNonce","rerender","useCallback","currentCount","countOnes","canvasRef","useRef","current","context","getContext","w","width","window","innerWidth","h","height","innerHeight","clearRect","fillStyle","fillRect","color","className","style","display","flexDirection","justifyContent","padding","onClick","type","min","onChange","e","newScale","Number","parseFloat","target","newOrder","parseInt","maxWidth","str","splits","split","enteredRows","replace","cells","trim","filter","n","isNaN","deadcells","fromResult","readOnly","fillerFunc","setTimeout","ref","position","alignItems","textAlign","userSelect","backgroundColor","border","borderRadius","size","top","left","undefined","toString","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.c124f24a.chunk.js","sourcesContent":["export function CreateDoubledArray(order: number) {\r\n    let rows: number[][] = [];\r\n    // rows start at ORDER, and increase by 1 per row, reaching (2*ORDER) - 1 then decrease\r\n    let rowLength = order;\r\n    for (let i = 0; i < order; i++) {\r\n        rows[i] = [];\r\n        for (let j = 0; j < rowLength; j++) {\r\n            rows[i][j] = 0;\r\n        }\r\n        rowLength++;\r\n    }\r\n    rowLength--;\r\n    for (let i = order; i < order * 2 - 1; i++) {\r\n        rows[i] = [];\r\n        rowLength--;\r\n        for (let j = 0; j < rowLength; j++) {\r\n            rows[i][j] = 0;\r\n        }\r\n    }\r\n\r\n    return rows;\r\n}\r\n\r\nexport class DoubledCoord {\r\n    constructor(public x: number, public y: number) { }\r\n\r\n    static FromRowAndColumn(row: number, col: number) {\r\n        return new DoubledCoord(row, col * 2 - row);\r\n    }\r\n\r\n    toString() { return `${this.x}, ${this.y}` };\r\n\r\n    toRowAndColumn() {\r\n        let row = this.x;\r\n        let col = (this.y + this.x) / 2;\r\n        return { row, col };\r\n    }\r\n\r\n    static add(a: DoubledCoord, b: DoubledCoord) {\r\n        return new DoubledCoord(a.x + b.x, a.y + b.y);\r\n    }\r\n\r\n    static subtract(a: DoubledCoord, b: DoubledCoord) {\r\n        return new DoubledCoord(a.x - b.x, a.y - b.y);\r\n    }\r\n\r\n    static multiply(a: DoubledCoord, k: number) {\r\n        return new DoubledCoord(a.x * k, a.y * k);\r\n    }\r\n}","import { create } from 'domain';\nimport React from 'react';\nimport './App.css';\nimport { DoubledCoord } from './double';\n\ninterface Hex {\n  x: number;\n  y: number;\n}\n\nfunction distance(a: Hex, b: Hex): number {\n  return 0;\n}\n\nconst startOrder = 4;\n\nfunction createRows(order: number) {\n  let rows: number[][] = [];\n  // rows start at ORDER, and increase by 1 per row, reaching (2*ORDER) - 1 then decrease\n  let rowLength = order;\n  for (let i = 0; i < order; i++) {\n    rows[i] = [];\n    for (let j = 0; j < rowLength; j++) {\n      rows[i][j] = 0;\n    }\n    rowLength++;\n  }\n\n  // instead of shrinking OFFSET the new ones!\n  let deadCells = 0;\n  for (let i = order; i < order * 2 - 1; i++) {\n    rows[i] = [];\n    deadCells++;\n    rowLength--;\n    for (let j = 0; j < rowLength + deadCells - 1; j++) {\n      rows[i][j] = 0;\n      if (j < deadCells) {\n        rows[i][j] = -1;\n      }\n    }\n  }\n\n  return rows;\n}\n\nvar rows: number[][] = createRows(startOrder);\n\nfunction setInRows(rows: number[][], coord: DoubledCoord, value: number) {\n  const c = coord.toRowAndColumn();\n  if (rows[c.row] && rows[c.row][c.col] >= 0) {\n    rows[c.row][c.col] = value;\n  }\n}\n\n// -1 is empty cell, just for offset, always ignore these and never set a value there\n// 0 is empty\n// 1 is filled\n// 2 is blocked! (already a mid point!)\nfunction addNewDot(rows: number[][], i: number, j: number) {\n  if (rows[i][j] != 0) { return; }\n  // console.log(\"Adding dot\", i,j);\n\n  const newDot = DoubledCoord.FromRowAndColumn(i, j);\n\n  // for EVERY non-0 spot we need to find a mid point. if INTEGER then we block them\n\n  rows.forEach((arr, row) => {\n    arr.forEach((x, col) => {\n      if (x === 1) {\n        const otherDot = DoubledCoord.FromRowAndColumn(row, col);\n\n        // TODO block double points\n        const diff = DoubledCoord.subtract(newDot, otherDot);\n        const double1 = DoubledCoord.add(newDot, diff);\n        const double2 = DoubledCoord.add(otherDot, DoubledCoord.multiply(diff, -1));\n        setInRows(rows, double1, 3);\n        setInRows(rows, double2, 3);\n\n        // TODO block mid point\n        // mid point should be AVERAGE og the 2 spots.\n        const midDot = DoubledCoord.multiply(DoubledCoord.add(otherDot, newDot), .5);\n        const mid = midDot.toRowAndColumn();\n        setInRows(rows, midDot, 2);\n      }\n    });\n  })\n\n  rows[i][j] = 1;\n}\n\nfunction iterRowCol(rows: number[][], func: (value: number, row: number, col: number, rows: number[][]) => void) {\n  rows.forEach((arr, row) => {\n    arr.forEach((value, col) => {\n      func(value, row, col, rows);\n    });\n  });\n}\n\nfunction countOnes(rows: number[][]) {\n  let count = 0;\n  iterRowCol(rows, (x) => {\n    if (x === 1) { count++; }\n  });\n  return count;\n}\n\nfunction countBlocked(rows: number[][]) {\n  let count = 0;\n  iterRowCol(rows, (x) => {\n    if (x > 1) { count++; }\n  });\n  return count;\n}\n\n\nfunction clear(rows: number[][]) {\n  iterRowCol(rows, (x, row, col) => {\n    if (x > 0) { rows[row][col] = 0; }\n  });\n}\n\nfunction copy(rows: number[][]) {\n  let newRows: number[][] = [];\n  iterRowCol(rows, (value, row, col) => {\n    newRows[row] = newRows[row] || [];\n    newRows[row][col] = value;\n  });\n  return newRows;\n}\n\nfunction result(rows: number[][]) {\n  return rows.map((row) => {\n    const indexes: number[] = [];\n    let deadCells = 0;\n    row.forEach((x, col) => {\n      if (x === -1) { deadCells++ }\n      // this doesn't handle DEAD CELLS!\n      if (x === 1) indexes.push(col - deadCells);\n    });\n    return `{${indexes.join(',')}}`;\n  }).join(', ');\n}\n\nfunction fromResult(str: string) {\n  console.log(\"entered!\");\n\n  // parse the string and turn it into rows and set the rows...\n  const splits = str.split(\"},\");\n  const order = (splits.length + 1) / 2;\n  console.log(\"I think it is order\", order);\n  const enteredRows = createRows(order);\n\n  // this doesn't handle DEAD CELLS!\n  splits.forEach((row, i) => {\n    row = row.replace(\"{\", \"\");\n    row = row.replace(\"}\", \"\");\n    console.log(\"row\", row);\n    const cells = row.split(\",\").map(c => Number.parseInt(c.trim())).filter(n => !isNaN(n));\n    console.log(cells);\n    // j needs to be offset by number of deadcells in that row.\n    const deadcells = enteredRows[i].filter(x => x === -1).length;\n    cells.forEach(j => {\n      addNewDot(enteredRows, i, j + deadcells);\n    });\n  });\n\n  return {\n    order,\n    rows: enteredRows,\n  };\n}\n\nfunction getRandom(max: number) {\n  return Math.floor(Math.random() * max);\n}\n\nfunction randomOrder(num: number) {\n  // place a random order or 1-num in an array.\n  var arr = [];\n  for (let i = 0; i < num; i++) {\n    arr.push({\n      index: i,\n      rand: Math.random()\n    });\n  }\n  arr.sort((a, b) => a.rand - b.rand);\n  return arr.map(x => x.index);\n}\n\nfunction time(count: number, func: () => void) {\n  const start = performance.now();\n\n  for (let i = 0; i < count; i++) {\n    func();\n  }\n\n  return performance.now() - start;\n}\n\nconsole.log(() => {\n  console.log(\"testing!\");\n\n  const newtime = time(1000, () => randomOpenCell(rows));\n  console.log(\"new time!\", newtime);\n\n  const oldtime = time(1000, () => old_randomOpenCell(rows));\n\n  console.log(\"old time!\", oldtime);\n\n});\n\nfunction randomOpenCell(rows: number[][]) {\n  const rowOrder = randomOrder(rows.length);\n  for (let i = 0; i < rows.length; i++) {\n    const row = rowOrder[i];\n    const row_arr = rows[row];\n\n    const openIndexes: number[] = [];\n    row_arr.forEach((x, col) => {\n      if (x === 0) {\n        openIndexes.push(col);\n      }\n    });\n\n    if (openIndexes.length) {\n      const col = getRandom(openIndexes.length);\n      return { row, col };\n    }\n  }\n\n  throw \"FULL!\";\n}\n\n// This checks every cell currently, which is quite impractical at larger sizes\nfunction fast_randomOpenCell(rows: number[][]) {\n  // this like.. DIES at the end....\n  for(let i = 0; i < 10000; i++){\n    const row = getRandom(rows.length);\n    const col = getRandom(rows[row].length);\n    if(rows[row][col] === 0){\n      return {row,col};\n    }\n  }\n  return old_randomOpenCell(rows);\n}\n\n// This checks every cell currently, which is quite impractical at larger sizes\nfunction old_randomOpenCell(rows: number[][]) {\n  let selected = { row: 0, col: 0 };\n  let curMax = -1;\n  let full = true;\n\n  // pick a random open cell \n  iterRowCol(rows, (x, row, col) => {\n    if (x === 0) {\n      full = false;\n      const r = Math.random();\n      if (r > curMax) {\n        curMax = r;\n        selected = { row, col };\n      }\n    }\n  });\n  if (full) { throw \"FULL!\" }\n  return selected;\n}\n\nfunction fillOne(rows: number[][], tries = 10) {\n  // ideally search open cells for whatever adds the LEAST blocked tiles\n  // or just check a few \n  let lowestBlocked = 999999999999999;\n  let lowestRows = rows;\n  for (let i = 0; i < tries; i++) {\n    const randomCell = fast_randomOpenCell(rows);\n    const newRows = copy(rows);\n    addNewDot(newRows, randomCell.row, randomCell.col);\n    const blocked = countBlocked(newRows);\n    if (blocked < lowestBlocked) {\n      lowestBlocked = blocked;\n      lowestRows = newRows;\n    }\n  }\n\n  return lowestRows;\n}\n\nlet best = 0;\nlet bestRows: number[][] = [];\n\nfunction App() {\n  const [scale, setScale] = React.useState(100);\n  const [tries, setTries] = React.useState(10);\n  const [order, setOrder] = React.useState(startOrder);\n\n  const [, setNonce] = React.useState(Math.random());\n  const rerender = React.useCallback(() => setNonce(Math.random()), [setNonce]);\n\n  const currentCount = countOnes(rows);\n  if (currentCount > best) {\n    best = currentCount;\n    bestRows = copy(rows);\n  }\n\n  const canvasRef = React.useRef<HTMLCanvasElement>(null);\n  if(canvasRef.current){\n    const context = canvasRef.current.getContext(\"2d\")!;\n    const w = canvasRef.current.width = window.innerWidth;\n    const h = canvasRef.current.height = window.innerHeight - 120;\n    context.clearRect(0,0,w,h);\n    context.fillStyle = \"black\";\n    context.fillRect(0,0,w,h);\n\n    const scale = h / rows.length;\n\n    iterRowCol(rows, (value, row,col)=>{\n      let color = \"white\";\n      switch (value) {\n        case -1: color = \"lightgrey\"; return;\n        case 1: color = \"red\"; break;\n        case 2: case 3: color = \"grey\"; break;\n      }\n\n      context.fillStyle = color;\n      const y = (DoubledCoord.FromRowAndColumn(row, col).x) * scale;\n      const x = (DoubledCoord.FromRowAndColumn(row, col).y + order) * (scale) / 2;\n      context.fillRect(x,y,scale,scale);\n    });\n  }\n\n  return (\n    <div className=\"App\" >\n      <div style={{ display: \"flex\", flexDirection: \"row\", justifyContent: \"space-around\", padding: 10 }}>\n        <button onClick={() => { clear(rows); rerender(); }}>Clear</button>\n        <span>Scale: <input type=\"range\" min=\"1\" max=\"100\" value={scale} onChange={e => {\n          const newScale = Number.parseFloat(e.target.value);\n          setScale(newScale);\n          rerender();\n        }} /></span>\n        <span>Order: <input type=\"number\" value={order} onChange={e => {\n          const newOrder = Number.parseInt(e.target.value)\n          setOrder(newOrder);\n          rows = createRows(newOrder);\n          best = 0;\n          rerender();\n        }} /></span>\n        <span> Score: {currentCount}</span>\n        <span> Best: {best}</span>\n      </div>\n\n      <div>\n        Current: <input style={{ maxWidth: 2000 }} value={result(rows)} onChange={(e) => {\n          const str = e.target.value;\n          const result = fromResult(str);\n          rows = result.rows;\n          setOrder(result.order);\n          rerender();\n        }} />  Best: <input readOnly style={{ maxWidth: 200 }} value={result(bestRows)} />\n\n      </div>\n      <div>\n        Tries: <input type=\"number\" value={tries} style={{ width: 50 }} onChange={(e) => setTries(Number.parseInt(e.target.value))} />\n        <button onClick={() => {\n          try {\n            rows = fillOne(rows, tries);\n            rerender();\n          }\n          catch { }\n        }}>Fill NEXT</button>\n        <button onClick={() => {\n          const fillerFunc = () => {\n            try {\n              rows = fillOne(rows, tries);\n              rerender();\n              setTimeout(fillerFunc, 0);\n            }\n            catch { };\n          }\n\n          fillerFunc();\n        }}>Fill All</button>\n        <button onClick={() => {\n          let count = 0;\n          let maxCount = 10;\n          const fillerFunc = () => {\n            if (count > maxCount) { return; }\n            try {\n              rows = fillOne(rows, tries);\n              rerender();\n              setTimeout(fillerFunc, 0);\n            }\n            catch {\n              count++;\n              clear(rows);\n              setTimeout(fillerFunc, 0);\n            };\n          };\n          fillerFunc();\n        }}>Fill 10</button>\n      </div>\n\n      {order > 50 ? <canvas style={{display:\"block\", width: \"100%\", height: \"100%\"}} ref={canvasRef}></canvas> : null}\n\n      <div style={{ position: \"relative\", scale: `${scale / 100}` }}>\n        {order <= 50 ? rows.map((r, i) => <div key={i} style={{ display: \"flex\", justifyContent: \"center\" }}>\n          {r.map((x, j) => {\n            let color = \"white\";\n            switch (x) {\n              case -1: color = \"lightgrey\"; break;\n              case 1: color = \"red\"; break;\n              case 2: case 3: color = \"grey\"; break;\n            }\n\n            const size = 50;\n\n            return <div key={j}\n              style={{\n                width: size,\n                height: size,\n                display: x === -1 ? \"none\" : \"flex\",\n                alignItems: \"center\",\n                textAlign: \"center\",\n                justifyContent: \"center\",\n                userSelect: \"none\",\n                backgroundColor: color,\n                border: \"1px solid black\",\n                borderRadius: size * 2,\n                position: \"absolute\",\n                top: (DoubledCoord.FromRowAndColumn(i, j).x) * size,\n                left: (DoubledCoord.FromRowAndColumn(i, j).y + order) * (size + 5) / 2,\n              }}\n              onClick={rows[i][j] <= 1 ? () => {\n                if (rows[i][j] === 1) {\n                  rows[i][j] = 0;\n                  // need to clear everything! yuck!\n                }\n                else if (rows[i][j] === 0) {\n                  addNewDot(rows, i, j);\n                }\n                rerender();\n              } : undefined}>{DoubledCoord.FromRowAndColumn(i, j).toString()}</div>;\n          })}\n        </div>) : null}\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}