{"version":3,"sources":["double.ts","App.tsx","reportWebVitals.ts","index.tsx"],"names":["DoubledCoord","x","y","this","row","col","a","b","k","createRows","order","rows","rowLength","i","j","deadCells","setInRows","coord","value","c","toRowAndColumn","addNewDot","newDot","FromRowAndColumn","forEach","arr","otherDot","diff","subtract","double1","add","double2","multiply","console","log","midDot","iterRowCol","func","countBlocked","count","copy","newRows","result","map","indexes","push","join","randomOpenCell","selected","curMax","full","r","Math","random","best","bestRows","App","React","useState","setOrder","useEffect","rerender","setNonce","useCallback","currentCount","countOnes","className","style","display","flexDirection","justifyContent","padding","onClick","type","onChange","e","Number","parseInt","target","maxWidth","splits","split","enteredRows","length","replace","cells","trim","filter","n","isNaN","lowestBlocked","lowestRows","randomCell","blocked","position","color","width","height","alignItems","textAlign","userSelect","backgroundColor","border","borderRadius","size","top","left","undefined","toString","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.b7f64290.chunk.js","sourcesContent":["export function CreateDoubledArray(order: number) {\r\n    let rows: number[][] = [];\r\n    // rows start at ORDER, and increase by 1 per row, reaching (2*ORDER) - 1 then decrease\r\n    let rowLength = order;\r\n    for (let i = 0; i < order; i++) {\r\n        rows[i] = [];\r\n        for (let j = 0; j < rowLength; j++) {\r\n            rows[i][j] = 0;\r\n        }\r\n        rowLength++;\r\n    }\r\n    rowLength--;\r\n    for (let i = order; i < order * 2 - 1; i++) {\r\n        rows[i] = [];\r\n        rowLength--;\r\n        for (let j = 0; j < rowLength; j++) {\r\n            rows[i][j] = 0;\r\n        }\r\n    }\r\n\r\n    return rows;\r\n}\r\n\r\nexport class DoubledCoord {\r\n    constructor(public x: number, public y: number) { }\r\n\r\n    static FromRowAndColumn(row: number, col: number) {\r\n        return new DoubledCoord(row, col * 2 - row);\r\n    }\r\n\r\n    toString() { return `${this.x}, ${this.y}` };\r\n\r\n    toRowAndColumn() {\r\n        let row = this.x;\r\n        let col = (this.y + this.x) / 2;\r\n        return { row, col };\r\n    }\r\n\r\n    static add(a: DoubledCoord, b: DoubledCoord) {\r\n        return new DoubledCoord(a.x + b.x, a.y + b.y);\r\n    }\r\n\r\n    static subtract(a: DoubledCoord, b: DoubledCoord) {\r\n        return new DoubledCoord(a.x - b.x, a.y - b.y);\r\n    }\r\n\r\n    static multiply(a: DoubledCoord, k: number) {\r\n        return new DoubledCoord(a.x * k, a.y * k);\r\n    }\r\n}","import { create } from 'domain';\nimport React from 'react';\nimport './App.css';\nimport { DoubledCoord } from './double';\n\ninterface Hex {\n  x: number;\n  y: number;\n}\n\nfunction distance(a: Hex, b: Hex): number {\n  return 0;\n}\n\nconst startOrder = 4;\n\nfunction createRows(order: number) {\n  let rows: number[][] = [];\n  // rows start at ORDER, and increase by 1 per row, reaching (2*ORDER) - 1 then decrease\n  let rowLength = order;\n  for (let i = 0; i < order; i++) {\n    rows[i] = [];\n    for (let j = 0; j < rowLength; j++) {\n      rows[i][j] = 0;\n    }\n    rowLength++;\n  }\n\n  // instead of shrinking OFFSET the new ones!\n  let deadCells = 0;\n  for (let i = order; i < order * 2 - 1; i++) {\n    rows[i] = [];\n    deadCells++;\n    rowLength--;\n    for (let j = 0; j < rowLength + deadCells - 1; j++) {\n      rows[i][j] = 0;\n      if (j < deadCells) {\n        rows[i][j] = -1;\n      }\n    }\n  }\n\n  return rows;\n}\n\nvar rows: number[][] = createRows(startOrder);\n\nfunction midPoint(i: number, j: number, oi: number, oj: number) {\n  // i first...\n\n}\n\nfunction doublePoint(di: number, dj: number, order: number) {\n  // for every j over HALF? we subtract 1?\n  if (di >= order) {\n    // double crosses boundary\n    console.log(\"across!\", di, order, di - order);\n    dj -= (di - order) + 1;\n  }\n\n  if (rows[di] && rows[di][dj] >= 0) {\n    console.log(\"adding double point\", di, dj);\n    rows[di][dj] = 2;\n  }\n}\n\nfunction ForEveryPoint(map: number[][], func: (map: number[][], row: number, col: number, value: number) => void) {\n  map.forEach((arr, row) => {\n    arr.forEach((value, col) => {\n      func(map, row, col, value);\n    });\n  });\n}\n\nfunction setInRows(rows: number[][], coord: DoubledCoord, value: number) {\n  const c = coord.toRowAndColumn();\n  if (rows[c.row] && rows[c.row][c.col] >= 0) {\n    rows[c.row][c.col] = value;\n  }\n}\n\n// -1 is empty cell, just for offset, always ignore these and never set a value there\n// 0 is empty\n// 1 is filled\n// 2 is blocked! (already a mid point!)\nfunction addNewDot(rows: number[][], i: number, j: number) {\n  if (rows[i][j] != 0) { return; }\n\n  const newDot = DoubledCoord.FromRowAndColumn(i, j);\n\n  // for EVERY non-0 spot we need to find a mid point. if INTEGER then we block them\n\n  rows.forEach((arr, row) => {\n    arr.forEach((x, col) => {\n      if (x === 1) {\n        const otherDot = DoubledCoord.FromRowAndColumn(row, col);\n\n        // TODO block double points\n        const diff = DoubledCoord.subtract(newDot, otherDot);\n        const double1 = DoubledCoord.add(newDot, diff);\n        const double2 = DoubledCoord.add(otherDot, DoubledCoord.multiply(diff, -1));\n        setInRows(rows, double1, 3);\n        setInRows(rows, double2, 3);\n\n        // TODO block mid point\n        // mid point should be AVERAGE og the 2 spots.\n        console.log(\"new\", newDot);\n        console.log(\"other\", otherDot);\n        const midDot = DoubledCoord.multiply(DoubledCoord.add(otherDot, newDot), .5);\n        console.log(\"avg\", DoubledCoord.multiply(DoubledCoord.add(otherDot, newDot), .5));\n        const mid = midDot.toRowAndColumn();\n        setInRows(rows, midDot, 2);\n      }\n    });\n  })\n\n  rows[i][j] = 1;\n}\n\nfunction iterRowCol(rows: number[][], func: (value: number, row: number, col: number, rows: number[][]) => void) {\n  rows.forEach((arr, row) => {\n    arr.forEach((value, col) => {\n      func(value, row, col, rows);\n    });\n  });\n}\n\nfunction countOnes(rows: number[][]) {\n  let count = 0;\n  iterRowCol(rows, (x) => {\n    if (x === 1) { count++; }\n  });\n  return count;\n}\n\nfunction countBlocked(rows: number[][]) {\n  let count = 0;\n  iterRowCol(rows, (x) => {\n    if (x > 1) { count++; }\n  });\n  return count;\n}\n\n\nfunction clear(rows: number[][]) {\n  iterRowCol(rows, (x, row, col) => {\n    if (x > 0) { rows[row][col] = 0; }\n  });\n}\n\nfunction copy(rows: number[][]) {\n  let newRows: number[][] = [];\n  iterRowCol(rows, (value, row, col) => {\n    newRows[row] = newRows[row] || [];\n    newRows[row][col] = value;\n  });\n  return newRows;\n}\n\nfunction result(rows: number[][]) {\n  return rows.map((row) => {\n    const indexes: number[] = [];\n    let deadCells = 0;\n    row.forEach((x, col) => {\n      if (x === -1) { deadCells++ }\n      // this doesn't handle DEAD CELLS!\n      if (x === 1) indexes.push(col - deadCells);\n    });\n    return `{${indexes.join(',')}}`;\n  }).join(', ');\n}\n\nfunction randomOpenCell(rows: number[][]) {\n  let selected = { row: 0, col: 0 };\n  let curMax = -1;\n  let full = true;\n  iterRowCol(rows, (x, row, col) => {\n    if (x === 0) {\n      full = false;\n      const r = Math.random();\n      if (r > curMax) {\n        curMax = r;\n        selected = { row, col };\n      }\n    }\n  });\n  if (full) { throw \"FULL!\" }\n  return selected;\n}\n\nlet best = 0;\nlet bestRows: number[][] = [];\n\nfunction App() {\n  const [order, setOrder] = React.useState(startOrder);\n  React.useEffect(() => {\n    createRows(order);\n    best = 0;\n    rerender();\n  }, [order, setOrder]);\n\n  const [, setNonce] = React.useState(Math.random());\n  const rerender = React.useCallback(() => setNonce(Math.random()), [setNonce]);\n\n  const currentCount = countOnes(rows);\n  if (currentCount > best) {\n    best = currentCount;\n    bestRows = copy(rows);\n  }\n\n  return (\n    <div className=\"App\" >\n      <div style={{ display: \"flex\", flexDirection: \"row\", justifyContent: \"space-around\", padding: 10 }}>\n        <button onClick={() => { clear(rows); rerender(); }}>Clear</button>\n        <span>Order: <input type=\"number\" value={order} onChange={e => {\n          setOrder(Number.parseInt(e.target.value));\n          rerender();\n        }} /></span>\n        <span> Score: {currentCount}</span>\n        <span> Best: {best}</span>\n      </div>\n\n      <div>\n        Current: <input style={{ maxWidth: 100 }} value={result(rows)} onChange={(e) => {\n          // parse the string and turn it into rows and set the rows...\n\n          const str = e.target.value;\n\n          const splits = str.split(\"},\");\n\n          const enteredRows = createRows((rows.length + 1)/ 2);\n\n          splits.forEach((row, i) => {\n            row = row.replace(\"{\", \"\");\n            console.log(\"row\", row);\n            const cells = row.split(\",\").map(c => Number.parseInt(c.trim())).filter(n => !isNaN(n));\n            console.log(cells);\n            cells.forEach(j => {\n              addNewDot(enteredRows, i, j);\n            });\n          });\n\n          rows = enteredRows;\n          rerender();\n        }} />\n        Best<input style={{ maxWidth: 100 }} value={result(bestRows)} />\n        <button onClick={() => {\n          try {\n            // ideally search open cells for whatever adds the LEAST blocked tiles\n            // or just check a few \n\n            let lowestBlocked = 999999999999999;\n            let lowestRows = rows;\n            const checkNum = 10;\n            for (let i = 0; i < checkNum; i++) {\n              const randomCell = randomOpenCell(rows);\n              const newRows = copy(rows);\n              addNewDot(newRows, randomCell.row, randomCell.col);\n              const blocked = countBlocked(newRows);\n              if (blocked < lowestBlocked) {\n                lowestBlocked = blocked;\n                lowestRows = newRows;\n              }\n            }\n\n            rows = lowestRows;\n            rerender();\n          }\n          catch { }\n        }}>Fill NEXT</button>\n      </div>\n\n      <div style={{ position: \"relative\" }}>\n        {order < 19 ? rows.map((r, i) => <div key={i} style={{ display: \"flex\", justifyContent: \"center\" }}>\n          {r.map((x, j) => {\n            let color = \"white\";\n            switch (x) {\n              case -1: color = \"lightgrey\"; break;\n              case 1: color = \"red\"; break;\n              case 2: case 3: color = \"grey\"; break;\n            }\n\n            const size = 50;\n\n            return <div key={j}\n              style={{\n                width: size,\n                height: size,\n                display: x === -1 ? \"none\" : \"flex\",\n                alignItems: \"center\",\n                textAlign: \"center\",\n                justifyContent: \"center\",\n                userSelect: \"none\",\n                backgroundColor: color,\n                border: \"1px solid black\",\n                borderRadius: size * 2,\n                position: \"absolute\",\n                top: (DoubledCoord.FromRowAndColumn(i, j).x) * size,\n                left: (DoubledCoord.FromRowAndColumn(i, j).y + order) * (size + 5) / 2,\n              }}\n              onClick={rows[i][j] <= 1 ? () => {\n                if (rows[i][j] === 1) {\n                  rows[i][j] = 0;\n                  // need to clear everything! yuck!\n                }\n                else if (rows[i][j] === 0) {\n                  addNewDot(rows, i, j);\n                }\n                rerender();\n              } : undefined}>{DoubledCoord.FromRowAndColumn(i, j).toString()}</div>;\n          })}\n        </div>) : null}\n      </div>\n    </div>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}